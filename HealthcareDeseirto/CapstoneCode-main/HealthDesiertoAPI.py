# -*- coding: utf-8 -*-
"""final_project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Iq9SDQQ-x7olwHS4cSYLyZWbcDc4Aozl

# #Step 1: Search for Healthcare Facilities

Create Google Places API and load it in

Save the info from the facility

Things to be saved

Name of facility

Address

Lat/Long

Place ID

Business Status

Load libraries
"""

import json
import requests
import time
import pandas as pd
from geopy.distance import geodesic
from math import radians, cos, sin, sqrt, atan2
from tqdm import tqdm

"""Load in Google Places API"""

# @title Default title text
#Load in Google Places API using json format
with open('config.json') as config_file:
    config = json.load(config_file)

API_KEY = config.get('API_KEY')

# Set up error message
if not API_KEY:
  raise ValueError("API_KEY not found in config.json")

"""Create helper functions to retreive the URLS

get_base_url function
"""

def get_base_url():
  return "https://places.googleapis.com/v1/places"

"""get_search_url"""

def get_search_url():
  return f"{get_base_url()}:searchText"

"""get_facility_details_url function

"""

def get_facility_details_url(place_id):
  return f"{get_base_url()}/{place_id}"

"""Set up location and search_keywords"""

location = 'Tucson, Arizona'
search_keywords = ['healthcare facility', 'healthcare', 'clinic', 'hospital', 'medical institution', 'health center', 'healthcare center', 'medical', 'clinica', 'cl√≠nica', 'medica']

"""Create search_places function to search for healthcare facilities that match the keyword search"""

# Create search_places function
def search_places(location, keywords):

  # Save results of api call
  healthcare = []

  # Create a set to remove duplicates
  place_ids = set()

  for keyword in keywords:
    # query
    query = f"{keyword} in {location}"

    #url
    url = f"{get_search_url()}?key={API_KEY}"

    #body
    body = {
        "textQuery": query
    }

    #params
    params = {
        "fields": "places.displayName,places.formattedAddress,places.location,places.id,places.businessStatus"
    }

    # Send post request
    response = requests.post(url, params=params, json=body)

    # check if the reponse was succesful, if not print error message
    if not response.ok:
      print(f"Error: Request failed with status code {response.status_code} - {response.reason}")
      continue

    try:
      data = response.json()
      time.sleep(2)
    except Exception as e:
      print(f" JSON decode error: {e}")
      continue

    # Grab the name, longitude and latitude from the healthcare facility that matches the keyword and add to healthcare list
    if data.get("places"):
      for place in data["places"]:
        place_id = place["id"]
        if place_id not in place_ids:
          place_ids.add(place_id)
          entry = {
              'name': place['displayName']['text'],
              'address': place['formattedAddress'],
              'latitude': place['location']['latitude'],
              'longitude': place['location']['longitude'],
              'place_id': place['id'],
              'business_status': place.get('businessStatus', "UNKNOWN"),
              'matched_keyword': keyword
          }
        healthcare.append(entry)
  else:
    # Print No results found for the keyword
    print(f"No results found for {query}")

  time.sleep(1)

  return healthcare

"""# Create results variable to hold locations found"""

# create results variable
results = search_places(location, search_keywords)

"""#Step 2: Filter by business status

Keep count of number of facilities

Operational

*Closed Temporarily

*Closed Permanently

Create function that filters through facilities found by keyword match and keeps only faicilities that are currently operational
"""

# Create operational_facilities function
def operational_facilities(places):
  operational = []
  counts = {
      "total": len(places),
      "operational": 0,
      "unknown_status": 0
  }

  for place in places:
    status = place.get("business_status", "UNKNOWN")

    if status == "OPERATIONAL":
      operational.append(place)
      counts["operational"] += 1
    else:
      counts["unknown_status"] += 1

  return operational, counts

"""Print out the total number of Operational Healthcare Facilities"""

filtered_places, status_counts = operational_facilities(results)
print(f"Facility Status Summary:")
for key, val in status_counts.items():
  print(f"{key.capitalize()}: {val}")

"""#Step 3: Get Details for Operational Facilities

Phone Number

Business Hours

Create function to extract the business details for each operational Healthcare Facility
"""

# Create get_facility_details function
def get_facility_details(place_id):
  # Set up url
  url = f"{get_facility_details_url(place_id)}?key={API_KEY}"

  # set up params
  params = {
      "fields": "displayName,formattedAddress,internationalPhoneNumber,regularOpeningHours.weekdayDescriptions"
      }

  # Create response
  response = requests.get(url, params=params)

  # Print Error Message if it fails
  if not response.ok:
    print(f"Failed to get details for Place ID: {place_id}")
    print("Status code:", response.status_code)
    print("Response:", response.text)
    return {}

  try:
    return response.json()
  except Exception as e:
    print(f"JSON error on details request: {e}")
    return {}

  time.sleep(1)

  return data

"""Use for loop to add facility details"""

def add_facility_details(places, delay=0.25):
  # Create facility details list to add details of facility
  facility_details = []
  total = len(places)

  estimated_total = round(total * delay, 2)
  print(f"Estimated time to update facility profile: ~{estimated_total} seconds ({round(estimated_total / 60, 2)} minutes)\n")

  count = 0
  for place in places:
    count += 1
    print(f"Updating profile details {count}/{total}: {place['name']}")

    details = get_facility_details(place["place_id"])
    place["phone"] = details.get("internationalPhoneNumber", "N/A")
    # Format hours while looping through
    hours = details.get("regularOpeningHours", {}).get("weekdayDescriptions", [])
    place["business_hours"] = "\n".join(hours) if hours else "N/A"

    facility_details.append(place)

    time.sleep(delay)

  print("Facility profile completed!")

  return facility_details

"""Save facility_details to variable"""

facility_details = add_facility_details(filtered_places)

"""Deduplicate the results"""

unique_results = list({(f['name'], f['latitude'],f['longitude']): f for f in facility_details}.values())

print("Total facilities:", len(results))
print("Unique facilities:", len(unique_results))

"""#Step 4: Clean the bus stop data

Check for duplicates

Check for na values

Create new df

Keep only the relevant columns and add to new df

Clean up the latitude and longitude coordinates

Load in the bus_stop.csv file
"""

# load in bus_stop.csv
bus_stops = pd.read_csv('bus_stops.csv')

"""Check for duplicates"""

bus_stops.duplicated().sum()

"""Check for na values"""

# Check bus_stops data frame for na values
bus_stops.isna().sum()

"""Drop the telephone column then drop the rows with na values"""

# drop the telephone column
bus_stops.drop(columns=['Telephone', 'UA'], inplace=True)

#drop the rows with the na values
bus_stops.dropna(inplace=True)

"""Drop unnecessary columns and add to newly created data frame"""

# Create new bus dataframe using OBJECTID, Long, Lat, GeoStatus, InService, URL
bus = pd.DataFrame()

"""Clean up Latitude and Longitude coordinates"""

# Create function to get latitude and logitude in correct format gor Google Maps
def convert_microdegrees(value):
  try:
    return float(value) / 1_000_000
  except:
    return None

"""Convert the Latitude and Longitude coordinates using convert_microdegrees function"""

# Convert the Longitude and Latitude column values
bus_stops.loc[:, 'Latitude'] = bus_stops['Lat'].apply(convert_microdegrees)
bus_stops.loc[:, 'Longitude'] = bus_stops['Lon'].apply(convert_microdegrees)

bus = bus_stops[['OBJECTID', 'Longitude', 'Latitude','GeoStatus', 'InService', 'URL']].copy()

"""#Step 5: Find the nearest intersections for each facility and bus stop

Set up Geocode API

Create function that find the nearest location for each facilities

Create function that find the nearest intersections for each bus stop

Set up Base Geocode URL
"""

# Create helper function to get base URL
def get_geocode_base_url():
  return "https://maps.googleapis.com/maps/api/geocode/json"

"""Create get_nearest intersection function"""

# Create get_nearest function
def get_nearest_intersection(lat, lon, API_KEY, delay=0.25):

  # set up time delay
  time.sleep(delay)

  # Round lat and long coordinates
  lat = round(lat, 6)
  lon = round(lon, 6)

  # Set up url
  url = get_geocode_base_url()

  # Set up params
  params = {
      'latlng': f"{lat},{lon}",
      'result_type': 'intersection',
      'key': API_KEY
  }

  # Send request
  response = requests.get(url, params=params)

  if response.ok:
    data = response.json()
    results = data.get("results", [])
    if results:
      return results[0]['formatted_address']
    else:
      return "Intersection Not Found"

  else:
    print(f"Failed for {lat}, {lon}) - Status code: {response.status_code}")
    return "Error"

intersection = get_nearest_intersection(32.211012, -110.974632, API_KEY)
print(intersection)

"""#Step 6:  Check for nearby Public Transport

Calculate the distance to each bus stop using lat/long

Determine radius (how many feet is considered reasonable for someone to walk from the bus stop to the healthcare facility)

If the facility is considered to be in the determined radius, consider it to be nearby

Create helper function for the Distance Matrix API base url
"""

# Create get distance function base url
def get_distance_matrix_base_url():
  return "https://maps.googleapis.com/maps/api/distancematrix/json"

"""Create get the walking distance function"""

# Create walking distance function
def get_walking_distance(lat1, lon1, lat2, lon2, API_KEY, mode='driving'):
  if not API_KEY:
    return "No API key is provided"

  # Round coordinates the 6th decimal
  lat1 = round(lat1, 6)
  lat2 = round(lat2, 6)
  lon1 = round(lon1, 6)
  lon2 = round(lon2, 6)

  # Set up url
  url = get_distance_matrix_base_url()

  # Set up params
  params = {
      'origins': f"{lat1},{lon1}",
      'destinations': f"{lat1},{lon2}",
      'mode': mode,
      'key': API_KEY
  }

  # Create response
  response = requests.get(url, params=params)

  # check response status
  if response.ok:
    try:
      data = response.json()
      element = data['rows'][0]['elements'][0]
      if element['status'] == 'OK':
        return element['distance']['value']
      else:
        return f"No route found: {element['status']}"
    except Exception as e:
      return f"JSON parsing error: {e}"
  else:
    return f"API call failed with status code {response.status_code}"

"""Create function to convert meters to feet"""

# Create function to convert m to ft
def convert_meters_to_feet(meters):
  try:
    feet = float(meters) * 3.28084
    return round(feet,2)
  except (TypeError, ValueError):
    return None

"""Create function to display the distance in meters"""

# function to display the converted distance in feet from meters
def display_distance(meters):
  feet = convert_meters_to_feet(meters)
  if feet is not None:
    return f"The distance of the Healthcare facility from the bus stop is", {feet}, "feet"
  else:
    return "Invalid distance"

"""Create function to calculate the closest distance to the bus stop coordinates"""

def haversine_distance(lat1, lon1, lat2, lon2):
  R = 63710000
  phi1, phi2 = radians(lat1), radians(lat2)
  delta_phi = radians(lat2 - lat1)
  delta_lambda = radians(lon2 - lon1)

  a = sin(delta_phi / 2) ** 2 + cos(phi1) * cos(phi2) * sin(delta_lambda / 2) ** 2
  c = 2 * atan2(sqrt(a), sqrt(1 - a))

  return R * c

def find_closest_bus(facility_lat, facility_lon, bus, top_n=3, delay=0.25):
  bus['straight_line_meters'] = bus.apply(
      lambda row: haversine_distance(facility_lat, facility_lon, row['Latitude'], row['Longitude']), axis=1
  )

  closest_stops = bus.nsmallest(top_n, 'straight_line_meters')

  min_distance = float("inf")
  closest_stop = None

  for _, row in closest_stops.iterrows():
    time.sleep(delay)

    distance_meters = get_walking_distance(facility_lat, facility_lon, row['Latitude'], row['Longitude'], API_KEY)

    if isinstance(distance_meters, (int, float)) and distance_meters < min_distance:
      min_distance = distance_meters
      closest_stop = row

  return min_distance, closest_stop

# Create function to find the closest matching route to the healthcare facility
def facility_to_bus_route(results, bus, API_KEY, delay=0.25):
  outcomes = []
  processed_names = set()

  for facility in tqdm(results, desc="Matching to bus stops", unit="facility"):
    facility_lat = facility['latitude']
    facility_lon = facility['longitude']
    facility_name = facility.get('name', 'Unknown Facility')

    if  facility_name in processed_names:
      print(f"Duplicate facility detected: {facility_name}")
    processed_names.add(facility_name)

    time.sleep(delay)

    min_distance, closest_stop = find_closest_bus(facility_lat, facility_lon, bus)

    if closest_stop is not None:
      outcome = {
          "facility_name": facility_name,
          "facility_lat": facility_lat,
          "facility_lon": facility_lon,
          "bus_stop_name": closest_stop['OBJECTID'],
          "bus_stop_lat": closest_stop['Latitude'],
          "bus_stop_lon": closest_stop['Longitude'],
          "distance_meters": min_distance,
          "distance_feet": convert_meters_to_feet(min_distance)
      }
      outcomes.append(outcome)
    else:
      print(f"No bus stop found for {facility['name']}")

  return outcomes

"""De-Duplicate facilities"""

outcomes = facility_to_bus_route(unique_results, bus, API_KEY, delay=0.3)

print("Original facilities", len(results))
print("Unique facilities after deduplication:", len(unique_results))

df = pd.DataFrame(outcomes)
dupes = df[df.duplicated(subset='name', keep=False)]
print(dupes[['name', 'latitude', 'longitude','business_status']])

"""Create new dataframe to hold the results"""

facility_names = [f.get('name', 'Unknown') for f in results]
print("Total facilities:", len(facility_names))
print("Unique facilities:", len(set(facility_names)))

restvals = list[{f['place_id']: f for f in results}.values()]

# Create new dataframe
matches = pd.DataFrame(outcomes)
print(matches[['facility_name', 'facility_lon', 'distance_meters', 'distance_feet']].head(10))

"""Need to download from gis data from the city of tucson
Sun Tran Express Bus Routes
Modern Streetcar Stops
Modern Streetcar Route (Polygon)

# Step 7: Summary Statistics

Keep counts for:

Total Operational Facilities

How many operational facilities are considered to be near public transport (based on our determined radius)
"""

# filtered_places variables hold the total number of operational facilities
#operational_count = outcomes[outcomes['business_status'] == 'OPERATIONAL'].shape[0]
#operational_counts = sum(1 for facility in outcomes if facility.get('business_status') == 'OPERATIONAL')
#print(f"Total Operational Facilities: {operational_counts}")
#status_counts = matches['business_status'].value_counts()
#print(f"Total Operational Facilities: {status_counts['OPERATIONAL']}")

"""# Step 8: Store data

To a json file

To a csv
"""
